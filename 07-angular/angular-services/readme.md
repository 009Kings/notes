![General Assembly Logo](http://i.imgur.com/ke8USTq.png)

#Angular Services

##Objectives

* Create a service to provide a RESTful resource using $resource
* Describe the difference between a factory and a service

## What are Angular Services?

Each web application you build with Angular is composed of objects that collaborate to get stuff done. These objects need to be instantiated and wired together using [dependency injection](https://docs.angularjs.org/guide/di) for the app to work.

When you inject a dependency into a module, e.g.

```javascript
angular.module("DoughnutApp", ['ui.bootstrap']);
```

The injector service needs to know how it should insert these objects. It does this by using **recipes**.

### Recipes

The main recipe that the injector needs to inject something into a module is called the **provider** recipe. However, on top of that, there are five other types of recipes which the injector uses to "cook" the dependency slightly differently. These recipes are:

1. **Factory** - the value returned by invoking the function reference
2. **Service** - the actual function reference
3. **Provider** - the value returned by invoking the $get method of the function reference
4. **Constant** - similar to a constant in other languages
5. **Value** - a literal value that can change

Each of these create a new object when they are used.

#### Services are Singletons

Angular [services](https://docs.angularjs.org/guide/services) (anything that can be injected as a dependency) are:

- **Lazily instantiated** – Angular only instantiates a service when it is needed
- **Singletons** – Each component dependent on a service gets a reference to the single instance generated by the service factory.

Once instantiated, unlike a controller, it persists throughout the lifetime of our app.

If your app needs data from an API or database, we probably don't want to keep loading that same data every time we change routes. Fetching that data once and holding it in a service makes a lot of sense.

Also, because services are persistent singletons, they provide a mechanism to share data between controllers.

### Factory vs service?

Factory and Service are the most commonly used recipes.  However, if factories and services are so similar, what's the difference? They look quite similar:

```javascript
angular.service('myService', myServiceFunction);
angular.factory('myFactory', myFactoryFunction);
```

**Service:**

...will be **renewed**, always creating a new object.

You should only make a service if you only ever need to and want to make one instance of it.  For example:

- A function that we want to wrap up in an object with a name so it's clear and useable to check whether a JWT token is acceptable & should be authorized or not
- A function to add Cross Origin Resource Sharing to our app, so an API can share JSON with any domain

**Factory:**

...will be invoked, which _can_ return an object.

It's possible to do the same things with both services and factories.

However, in some cases the factory gives you a little bit more flexibility because while the **service must always be an object**, the factory can be an object, a function reference, or any value at all.

##Resources

We're going to create a resource in order to interact with a RESTful API. Instead of using `$http` over and over again, we can use another module called `ngResource` to define an endpoint with HTTP verbs.

###Illustrating $resource

Before we dive into the service, let's see a simple example of using `ngResource`.

```js
var resourceObject = $resource('http://localhost:3000/api/airplanes/:id');
```

We'll be showing a more complete example in a moment, but notice that we can create a resource by using the `$resource` service. By providing a URL with a spot for an `id` parameter, this object will provide us the following methods:

```js
resourceObject.get([params], [success], [error]) //GET :id
resourceObject.save([params], postData, [success], [error]) //POST
resourceObject.query([params], [success], [error]) //GET all
resourceObject.remove([params], postData, [success], [error]) //DELETE :id
```

Woah, a RESTful interface for working with a RESTful API. Now that we've shown that example, let's create a service to provide this resource. Specifically, we'll be using the Doughnut API. http://api.doughnuts.ga/

##Doughnut App

First thing's first, let's add the correct dependencies to the starter code.

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular-resource.js"></script>
<script src="js/app.js"></script>
```

Note that in order to use `$resource`, we need to include a separate script in the `<head></head>` tags. We'll also need to inject `ngResource` into our app.

In `app.js`:

```js
var app = angular.module('DoughnutApp', ['ngResource']);

app.controller('DoughnutCtrl', ['$scope', function($scope) {

}]);
```

Make sure to add `ng-app` and `ng-controller` directives to `index.html` and test the app before continuing.

###Creating a Doughnut Service

Now, we're going to create a service using the factory recipe. This service will provide an object we can inject into controllers, and it'll provide functions for interacting with the Doughnut API.

We'll create this service in the same file for now.

In `app.js`, we'll create a factory and inject it into the controller.

```js
var app = angular.module('DoughnutApp', ['ngResource']);

app.factory('Doughnut', ['$resource', function($resource) {
  return $resource('http://api.doughnuts.ga/doughnuts/:id');
}]);

app.controller('DoughnutCtrl', ['$scope', 'Doughnut', function($scope, Doughnut) {
  console.log(Doughnut);
}]);
```

When we refresh the page, the contents of the Doughnut service should be logged to the browser console.

###Using the Doughnut service

In order to use the Doughnut service, we can call `get`, `query`, `save`, and `remove` from the controller.

In `app.js`:

```js
app.controller('DoughnutCtrl', ['$scope', 'Doughnut', function($scope, Doughnut) {
  $scope.doughnuts = [];
  Doughnut.query(function success(data) {
    $scope.doughnuts = data;
  }, function error(data) {
    console.log(data);
  });
}]);
```

In `index.html`:

```html
<div class="well" ng-repeat="doughnut in doughnuts">
  {{doughnut.style}} - {{doughnut.flavor}}
</div>
```

**Try it:** Use the `get` method from the Doughnut service to retrieve the second doughnut (id of 2).

###Why use a Service?

You may be wondering why we're using a service for a one-line resource. Usually, resources are more complex and can be customized as you see fit. Take a look at the [documentation for $resource](https://docs.angularjs.org/api/ngResource/service/$resource) and see what can be customized. Even if we didn't add additional customizations, the service allows many controllers to access the resource as a singleton.

Here's a trivial example of customizing our Doughnut resource, by specifying different function names.

```js
app.factory('Doughnut', ['$resource', function($resource) {
  return $resource('http://api.doughnuts.ga/doughnuts/:id', {}, {
    all: {method: 'GET', cache: false, isArray: true},
    get: {method: 'GET', cache: false, isArray: false},
    save: {method: 'POST', cache: false, isArray: false},
    update: {method: 'PUT', cache: false, isArray: false},
    delete: {method: 'DELETE', cache: false, isArray: false}
  });
}]);
```

Note that we set `isArray` to true for the GET all endpoint. We also set the `cache` to false, but it could be set to true for performance improvements. We also may want to customize the `all` endpoint in the future, if we want to limit results (imagine getting all Facebook users when calling `.all`).

##Conclusion

We've used services when working with `$http` and Bootstrap modals, and we just made our own. By doing so, we've isolated business logic out of our controllers, so that they can focus mainly on initializing and manipulating data.

Later, we'll add routing to this Doughnut app and implement all of the CRUD functions.
